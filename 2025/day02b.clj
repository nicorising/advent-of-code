(require '[clojure.math :as math])
(require '[clojure.string :as str])
(require '[clojure.test :as test])

(defn pow10 [x]
  (int (math/pow 10 x)))

; All the invalid IDs comprised of n digits repeated m times can be generated by
; multiplying all n-digit numbers with
; 10^(0 * n) + 10^(1 * n) + ... + 10^((m - 1) * n) = 10...010... ... ...010...01
; where there are m 1s with (n - 1) 0s between them
;
; E.g., the 2-digit repetitions of length 3 are:
; 10 * 10101 = 101010
; 11 * 10101 = 111111
; 12 * 10101 = 121212
; ...
; 99 * 10101 = 999999
(defn generate-invalid-ids [digits repeats]
  (map (fn [x]
         (* x (reduce + (map (fn [x] (pow10 (* x digits))) (range repeats)))))
       (range (pow10 (dec digits)) (pow10 digits))))

(defn invalid-ids-up-to [max-id]
  (let [max-pow (int (inc (math/ceil (math/log10 max-id))))]
    (flatten
     (map (fn [digits]
            (map (fn [repeats]
                   (generate-invalid-ids digits repeats))
                 (range 2 (/ max-pow digits))))
          (range 1 (/ max-pow 2))))))

(defn solve [input]
  (reduce + (distinct (let [ranges (map (fn [id-range]
                                          (map Long/parseLong (str/split id-range #"-")))
                                        (str/split (str/trim input) #","))
                            max-id (apply max (map (fn [range] (second range)) ranges))]
                        (filter (fn [id] (some (fn [range]
                                                 (let [[start end] range]
                                                   (<= start id end))) ranges))
                                (invalid-ids-up-to max-id))))))

(test/deftest day02b
  (test/is (= (solve (slurp "test_data/day02.txt")) 4174379265)))

(test/run-tests)

(println (solve (slurp "input.txt")))
