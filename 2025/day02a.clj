(require '[clojure.math :as math])
(require '[clojure.string :as str])
(require '[clojure.test :as test])

(defn pow10 [x]
  (int (math/pow 10 x)))

; All the invalid IDs comprised of n digits repeated twice can be generated by
; multiplying all n-digit numbers with 10^n + 1 = 10...01 where there are
; (n - 1) 0s in the middle
;
; E.g., the 6-digit (n = 3) invalid IDs are:
; 100 * 1001 = 100100
; 101 * 1001 = 101101
; 102 * 1001 = 102102
; ...
; 999 * 1001 = 999999
(defn invalid-ids-up-to [max-id]
  (let [max-pow (range 1 (inc (int (math/ceil (/ (math/log10 max-id) 2)))))]
    (flatten
     (map (fn [pow]
            (map (fn [x]
                   (* (inc (pow10 pow)) x))
                 (range (pow10 (dec pow))
                        (pow10 pow))))
          max-pow))))

(defn solve [input]
  (reduce + (let [ranges (map (fn [id-range]
                                (map Long/parseLong (str/split id-range #"-")))
                              (str/split (str/trim input) #","))
                  max-id (apply max (map (fn [range] (second range)) ranges))]
              (filter (fn [id] (some (fn [range]
                                       (let [[start end] range]
                                         (<= start id end))) ranges))
                      (invalid-ids-up-to max-id)))))

(test/deftest day02a
  (test/is (= (solve (slurp "test_data/day02.txt")) 1227775554)))

(test/run-tests)

(println (solve (slurp "input.txt")))
